# Зрiзи

Зрiзи - це об'єкти типу `T[]` для будь-якого заданого типу `Т`.
Зріз надає доступ до підмножини масиву значень
 `Т`, або просто вказує на весь масив.
**Зрiзи і динамічні масиви - це одне і те ж.**

Зріз складається з двох елементів - вказівник на початковий елемент та довжину зрізу:

    T* ptr;
    size_t length; // беззнакове 32-бiтне число на 32-бiтних платформах чи беззнакове 64-бiтне число на 64-бiтнх платформах.

Коли створюється новий динамічний масив, для зрiзу видiляється новий шматочок пам'ятi :

    auto arr = new int[5];
    assert(arr.length == 5); // пам'ять на яку посилається arr.ptr

Сiнтаксiс `[start..end]` визначає пiд-зріз існуючого
зрізу, який містить всі елементи від `start`-у до елементу _перед_` end`:

    auto newArr = arr[1 .. 4]; // iндекс 4 не врахований
    assert(newArr.length == 3);
    newArr[0] = 10; // змiнює newArr[0] який співпадає з arr[1]

Зрізи генерують новий доступ до існуючої пам'яті. Вони *не створюють* нову копію. Якщо жоден зрiз більше не містить посилання на пам'ять, або на її частину - вона буде звільнена збирачем сміття.



Зрізи надають можливість писати дуже ефективний код. Наприклад, парсери зазвичай працюють в одному блоці пам'яті, просто посилаючись на неї за допомогою зрiзiв - без необхідності виділяти нових блоків пам'яті.

Як було показано в попередньому розділі, вираз `[$]` є скороченою формою
для `arr.length`. Отже, `arr[$]` буде посилатись на елемент, який знаходиться за останнім елементом зрізу, таким чином буде генерувати `RangeError` (якщо не була відключена перевiрка кордону зрiзiв).

### Додатково

- [Введення у зрiзи в D](http://dlang.org/d-array-article.html)
- [Зрiзи в _Programming in D_](http://ddili.org/ders/d.en/slices.html)

## {SourceCode}

```d
import std.stdio;

/**
Рекурсивно розраховує мінімум всіх значень
у зрізі. Для кожного рекурсивного
виклику пiд-зріз береться таким чином, що ми не
створюємо копію і не робимо будь-яких призначень.
*/
int minimum(int[] slice)
{
    assert(slice.length > 0);
    if (slice.length == 1)
        return slice[0];
    auto otherMin = minimum(slice[1 .. $]);
    return slice[0] < otherMin ?
        slice[0] : otherMin;
}

void main()
{
    int[] test = [ 3, 9, 11, 7, 2, 76, 90, 6 ];
    auto min = minimum(test);
    writefln("The minimum of %s is %d",
        test, min);
    assert(min == 2);
}
```
