# Масиви

Є два типи масивів в D: **статичний** і **динамічний**
масиви. Доступ до масивів будь-якого роду завжди перевіряється на вихiд за межи масиву -
невдала перевірка діапазону дає `RangeError`, який перериває виконання програми.
Якщо ви хоробрий, то можете відключити перевiрку за допомогою опцii компілятора `-boundschecks = off` вичавлювати
останні цикли процесора.

#### Статичнi масиви

Статичні масиви зберігаються в стеку, якщо вони визначені всередині функції,
або в статичної пам'яті в іншому випадку. Вони мають фіксовану,
під час компіляції довжину. Статичний тип масиву включає в себе цей
фіксований розмір:

    int[8] arr;

Типом `arr` є `int[8]`. Зверніть увагу, що розмір масиву позначається
поруч з типом, а не після змінної, як в C / C ++.

#### Динамiчнi масиви

Динамічні масиви зберігаються в купі і можуть бути розширенi
або стиснутi під час виконання. Динамічний масив створюється за допомогою вираза `new` та потрiбної довжини:

    int size = 8; // run-time variable
    int[] arr = new int[size];

Типом `arr` є `int []`, який є **зрiзом**, що буде пояснено більш детально в наступному розділі. Багатовимірнi
масиви можуть бути легко створені за допомогою синтаксису `auto arr = new int[3][3]`.

#### Операції з масивами та їх властивості

Масиви можуть бути об'єднані за допомогою оператора `~`, який
створить новий динамічний масив.

Математичні операції можуть застосовуваться до цілих масивів з використанням синтаксису `c[] = а[] + b[]`,
який, наприклад, додає всі елементи `a` до `b` так, що
`c[0] = а[0] + b[0]`. `c[1] = а[1] + b[1]` і т.д. Крім того, можливо
виконання операцій з цілим масивом та одним значенням:

    a[] *= 2; // помножити всi елементи на 2
    a[] %= 26; // обчислити по модулю 26 для всіх елементів а

Ці операції можуть бути оптимізовані
компілятором так, що будуть використанi спеціальні інструкції процесора, які
завершать операцію за один крок.

Як статичнi, так і динамічнi масиви забезпечують властивість `.length`
яка призначена тільки для читання у разi статичних масивів, але у разi запису для динамічного масиву може змінювати його розмір. Властивість `.dup` створює копію масиву.

При індексації масиву через `arr[idx]` спеціальний символ
`$` позначає довжина масиву. Таким чином `arr[$ - 1]` є
посилання на останній елемент і є короткою формою для `arr[arr.length - 1]`.

### Вправа

Завершіть процедуру `encrypt` для розшифровки секретного повідомлення.
Текст повинен бути зашифрований з використанням шифрування *Caesar encryption*
що переміщує символи в алфавіті з використанням певного індексу.
Текст для шифрування містить тільки символи в діапазоні `а-z`
що повинно зробити програму простіше.

### Детальнiше

- [Масиви в _Programming in D_](http://ddili.org/ders/d.en/arrays.html)
- [Спецiфiкация на масиви](https://dlang.org/spec/arrays.html)

## {SourceCode:incomplete}

```d
import std.stdio;

/**
Зрушує кожен символ
масиву `input` на `shift` символів.
Набір символів обмежується `а-z, наступний символ після z є a.
Params:
    input = масив для зрушення
    shift = довжина для зрушення
Returns:
    зрушенний масив
*/
char[] encrypt(char[] input, char shift)
{
    auto result = input.dup;
    // ...
    return result;
}

void main()
{
    // Мы зашифруємо повiдомлення за допомогою
    // Caesar encryption
    // та фактором зсуву 16!
    char[] toBeEncrypted = [ 'w','e','l','c',
      'o','m','e','t','o','d',
      // Остання "," буде видкинута!
    ];
    writeln("Before: ", toBeEncrypted);
    auto encrypted = encrypt(toBeEncrypted, 16);
    writeln("After: ", encrypted);

    // Переконаємось, що алгоритм работає
    // як треба.
    assert(encrypted == [ 'm','u','b','s','e',
            'c','u','j','e','t' ]);
}
```
