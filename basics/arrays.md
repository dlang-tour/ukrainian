# Масиви

Є два типи масивів у D: **статичні** та **динамічні**. При доступі до
масиву будь-якого типу завжди є перевірка на вихiд за його межі.
Якщо це станеться, виконання програми перерветься з повідомленням про
помилку `RangeError`. Якщо ви сильні духом, то можете вимкнути перевiрку
за допомогою опцiї компілятора `-boundschecks=off`. Це дозволить вам
пришвидчити програму.

#### Статичнi масиви

Статичні масиви зберігаються у стеку, якщо вони оголошені всередині функції,
або у статичній пам'яті в інших випадках. Вони мають фіксовану довжину,
відому ще на етапі компіляції. Статичний тип масиву включає у себе
фіксований розмір:

    int[8] arr;

Типом `arr` є `int[8]`. Зверніть увагу, що розмір масиву вказаний
за типом, а не після змінної, як це робиться у C/C++.

#### Динамiчнi масиви

Динамічні масиви зберігаються у купі і можуть бути розширенi або
стиснутi під час виконання програми. Динамічний масив створюється за
допомогою ключового слова `new` разом з вказанням довжини:

    int size = 8; // run-time змінна
    int[] arr = new int[size];

Типом `arr` є `int[]`, який є **зрiзом** (slice), про який поговоримо
більш детально у наступному розділі. Багатовимірнi масиви можуть бути
легко створені за допомогою синтаксису `auto arr = new int[3][3]`.

#### Операції з масивами та їх властивості

Масиви можуть бути об'єднані за допомогою оператора конкатенації `~`,
який створить новий динамічний масив.

Математичні операції можуть застосовуватися до цілих масивів,
використовуючи наступний синтакс `c[] = а[] + b[]`,
який, наприклад, додасть всі елементи `a` до `b`, тобто вийде
`c[0] = а[0] + b[0]`, `c[1] = а[1] + b[1]` і т.д. Крім того, можливе
виконання операцій з цілим масивом та одним значенням:

    a[] *= 2; // помножити всi елементи на 2
    a[] %= 26; // значення по модулю 26 для всіх елементів а

Ці операції можуть бути оптимізовані компілятором таким чином, щоб
задіяти спеціальні інструкції процесора, які завершать ці операції
за один крок.

Як статичнi, так і динамічнi масиви мають властивість `.length`.
Її можна лише читати у разі статичних масивів, а у разі динамічних
масивів є можливість змінювати це значення, щоб динамічно змінювати
розмір масиву. Властивість `.dup` створює копію масиву.

При індексації масиву за допомогою синтаксису `arr[idx]` спеціальний
символ `$` позначає довжину масиву. Наприклад, `arr[$ - 1]` посилається
на останній елемент і є короткою формою запису `arr[arr.length - 1]`.

### Вправа

Завершіть функцію `encrypt` для розшифрування таємного повідомлення.
Текст повинен бути зашифрований з використанням *Шифру Цезаря*
(Caesar encryption), який зміщує символи в алфавіті, використовуючи
певний індекс. Текст для шифрування містить тільки символи з діапазону
`а-z`, що полегшує завдання.

### Додатково

- [Масиви у _Programming in D_](http://ddili.org/ders/d.en/arrays.html)
- [Специфiкація на масиви](https://dlang.org/spec/arrays.html)

## {SourceCode:incomplete}

```d
import std.stdio;

/**
  Зміщує кожен символ масиву
  `input` на `shift` символів.
  Набір символів обмежується
  `а-z`, наступний символ
  після z є a.

  На вхід:
    input = масив для зсуву
    shift = довжина для зсуву
  На вихід:
    зашифрований масив
*/
char[] encrypt(char[] input, char shift)
{
    auto result = input.dup;
    // ...
    return result;
}

void main()
{
    // Ми зашифруємо повiдомлення за допомогою
    // Шифру Цезаря з величиною зсуву 16!
    char[] toBeEncrypted = [ 'w','e','l','c',
      'o','m','e','t','o','d',
      // Остання "," буде викинута!
    ];
    writeln("Before: ", toBeEncrypted);
    auto encrypted = encrypt(toBeEncrypted, 16);
    writeln("After: ", encrypted);

    // Переконаємося,
    // що алгоритм працює коректно
    assert(encrypted == [ 'm','u','b','s','e',
            'c','u','j','e','t' ]);
}
```
