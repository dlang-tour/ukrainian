# Структури

Один із способів визначення складених або спеціалізованих типів в D є
визначення їх через `struct`:

    struct Person {
        int age;
        int height;
        float ageXHeight;
    }

Структури завжди будуються у стеці (якщо не створенi
з допомогою `new`) і копіюються **за значенням** при присвоєнн та
в якості параметрів у викликах функцій.

    auto p = Person(30, 180, 3.1415);
    auto t = p; // копіюється

Коли створюється новий об'єкт типу `struct` його члени можуть бути ініційовані
у тому ж порядку, в якому вони визначені в `struct`. Користувач сам може визначити конструктор за допомогою
функції-члену `this(...)`. У разі необхідності, щоб уникнути конфлікти імен, поточний екземпляр структури
може бути явно доступний за допомогою ключового слова `this`:

    struct Person {
        this(int age, int height) {
            this.age = age;
            this.height = height;
            this.ageXHeight = cast(float)age * height;
        }
            ...

    Person p(30, 180); // iнiцiалiзацiя
    p = Person(30, 180);  // призначення новим екземпляром

`struct` може містити будь-яку кількість функцій-членів. За замовчуванням усi вони мають рiвень захисту 
`public` і доступнi зовні. Вони можуть також мати рiвень захисту `private` і, таким чином, викликатися тiльки ззовнi
функціями-членами того ж типу `struct`, або іншим кодом того ж самого модуля.


    struct Person {
        void doStuff() {
            ...
        private void privateStuff() {
            ...

    p.doStuff(); // викликає метод doStuff
    p.privateStuff(); // заборонено

### функції-члени сonst

Якщо функція-член оголошується з `const`, вона не буде допущена
до зміни будь-якого з членів структури. Це забезпечується компілятором.
Створення функції-члена з позначкою `const` дає їй дозвіл на виклик у будь-якому `const`
або `immutable` об'єктi, і гарантує що функція-член ніколи не змінить стан об'єкта.

### Статичнi функції-члени

Якщо функція-член оголошена як `static`, вона буде викликатися
без екземпляра об'єкта (наприклад - `Person.myStatic()`), але їй заборонений доступ до будь-яких не-`static` членів.
`static` функція-член може бути використана вами щоб надати доступ до всіх екземплярів
`struct`, а не до поточного екземпляру, або коли функція-член може бути викликана користувачем, який не має доступного
екземпляру. Наприклад, сінглтони (або `Singleton`, які існують лише в одному екземплярi) використовують `static`.

### Успадкування

Зверніть увагу, що `struct` не може успадковуватись від іншого `struct`.
Iєрархiї типів можуть бути побудовані тільки з використанням класів,
з якими ми ознайомимось у наступному розіділі.
Однак з `alias this` або` mixins` можна легко досягти
поліморфного успадкування.

### Додатково

- [Структури в _Programming in D_](http://ddili.org/ders/d.en/struct.html)
- [Спецификацiя на структури](https://dlang.org/spec/struct.html)

### Вправа

Маючи `struct Vector3` реалізувати наступні функції і зробити
так, щоб приклад програми виконувався успішно:

* `length()` - повертає довжину вектору.
* `dot(Vector3)` - повертає множення векторiв.
* `toString()` - повертає рядкове уявлення вектору.
  Функцiя [`std.string.format`](https://dlang.org/phobos/std_format.html)
  вертає рядок використовуючи `printf`-подiбний синтаксис:
  `format("MyInt = %d", myInt)`. Рядки будуть пояснені у наступих секцiях.

## {SourceCode:incomplete}

```d
struct Vector3 {
    double x;
    double y;
    double z;

    double length() const {
        import std.math: sqrt;
        return 0.0;
    }

    // rhs буде скопійовано
    double dot(Vector3 rhs) const {
        return 0.0;
    }

    /**
    Повертає: рядкове уявлення спецiального
    формату.
    Вивід обмежений одинарною точнiстю!
    "x: 0.0 y: 0.0 z: 0.0"
    */
    string toString() const {
        import std.string: format;
        // підказка: дивіться документацію до
        // std.format, щоб дізнатись,
        // як форматувати числа з плаваючою
        // точкою.
        return format("");
    }
}

void main() {
    auto vec1 = Vector3(10, 0, 0);
    Vector3 vec2;
    vec2.x = 0;
    vec2.y = 20;
    vec2.z = 0;

    // Якщо функцiя-член не має аргументiв,
    // дужки "()" можуть бути пропущені.
    assert(vec1.length == 10);
    assert(vec2.length == 20);

    // Перевiрка фунцiональностi множення.
    assert(vec1.dot(vec2) == 0);

    // 1 * 1 + 2 * 1 + 3 * 1
    auto vec3 = Vector3(1, 2, 3);
    assert(vec3.dot(Vector3(1, 1, 1)) == 6);

    // 1 * 3 + 2 * 2 + 3 * 1
    assert(vec3.dot(Vector3(3, 2, 1)) == 10);

    // Завдяки toString() ми тепер можемо просто
    // вивести vector скориставшись writeln
    import std.stdio: writeln, writefln;
    writeln("vec1 = ", vec1);
    writefln("vec2 = %s", vec2);

    // Перевiрка рядкового уявлення
    assert(vec1.toString() ==
        "x: 10.0 y: 0.0 z: 0.0");
    assert(vec2.toString() ==
        "x: 0.0 y: 20.0 z: 0.0");
}
```
