# Пам'ять

D є системною мовою програмування. Таким чином, D дозволяє вручну
керувати пам'яттю. Проте, ручне керування пам'яттю є причиною багатьох
системних помилок, тому D використовує *збирач сміття* за замовчуванням,
щоб виділяти та звільняти пам'ять, яка вже не використовується.

D забезпечує вказівні типи `T*`, як у мові програмування C:

    int a;
    int* b = &a; // b містить адресу a
    auto c = &a; // c має тип int* та містить адресу a

Новий блок пам'яті у купі (heap) виділяється за допомогою оператора
`new`, який повертає вказівник на керовану пам'ять:

    int* a = new int;

Як тільки на пам'ять, яку використовує `a`, перестане посилатись
будь-яка змінна у програмі, збирач сміття звільнить цю пам'ять.

D має три різних рівня безпеки для функцій: `@system`, `@trusted`, та
`@safe`. За замовчуванням використовується рівень `@system`. `@safe`
рівень є підмножиною D, яка запобігає помилок пам'яті архітектурно.
`@safe` код можуть викликати тільки інші `@safe` чи `@trusted` функції.
Крім того, явна арифметика вказівників заборонена у `@ safe` коді:

    void main() @safe {
        int a = 5;
        int* p = &a;
        int* c = p + 5; // помилка
    }

`@trusted` функції є функціями, які потрібно перевіряти вручну. Вони
дозволяють організувати з'єднання між SafeD та брудним світом низького
рівня.

### Додатково

* [SafeD](https://dlang.org/safed.html)

## {SourceCode}

```d
import std.stdio;

void safeFun() @safe
{
    writeln("Привіт Світ");
    // виділення пам'яті з GC також безпечно
    int* p = new int;
}

void unsafeFun()
{
    int* p = new int;
    int* fiddling = p + 5;
}

void main()
{
    safeFun();
    unsafeFun();
}
```
