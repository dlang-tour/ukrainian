# Дiапазони

Коли компiлятор зустрічає вираз `foreach`

```
foreach (element; range)
{
    // Тіло циклу...
}
```

вiн на нижчому рівні перепиcує його в:

```
for (auto __rangeCopy = range;
     !__rangeCopy.empty;
     __rangeCopy.popFront())
 {
    auto element = __rangeCopy.front;
    // Тіло циклу...
}
```

Якщо об'єкт діапазону є посиланням (`class`), то діапазон можна
використовувати, але при цьому він не буде доступний для подальшої
ітерації (тільки якщо головний цикл завершиться чи перерветься до
потрібного циклу). Якщо об'єкт діапазону є простий тип (`int`,
`struct`...), буде зроблена копія діапазону і залежно від пособу
визначення діапазону у циклі або може або не може використовуватись
оригінальний діапазон. Більшість діапазонів у стандартній бібліотеці
є структурами, а отже ітерація за допомогою `foreach` зазвичай
неруйнівна, хоча це не гарантовано. Якщо гарантія важлива, потрібно
використовувати **forward** діапазони.

Будь-який об'єкт, який імплементує наступний інтерфейс, називається
**діапазон** і може пiдтримувати ітерації:

```
    struct Range
    {
        @property bool empty() const;
        void popFront();
        T front() const;
    }
```

Зверніть увагу, що хоч функції `empty` та `front` і позначені як `const`
(мається на увазі, що виклик їх не змінить `Range`), так робити не
обов'язково.

Функції у [`std.range`](http://dlang.org/phobos/std_range.html) і
[`std.algorithm`](http://dlang.org/phobos/std_algorithm.html) забезпечують будівельні блоки,
які використовують цей інтерфейс. Діапазони дозволяють створювати
складні алгоритми обробки об'єктiв, по яким може бути проведена
ітерація. Крім того, діапазони дозволяють створювати **ледачi**
об'єкти, які виконують обчислення тільки, коли це дійсно необхідно,
наприклад, коли наступний елемент діапазону є реально доступним.
Спецiальнi алгоритми для діапазонiв будуть описані пізніше у розділі
[Коштовності D](gems/range-algorithms).

### Вправа

Завершіть код та створіть дiапазон `FibonacciRange`, який повертає
[числа Фібоначчі](https://uk.wikipedia.org/wiki/%D0%9F%D0%BE%D1%81%D0%BB%D1%96%D0%B4%D0%BE%D0%B2%D0%BD%D1%96%D1%81%D1%82%D1%8C_%D0%A4%D1%96%D0%B1%D0%BE%D0%BD%D0%B0%D1%87%D1%87%D1%96).
Не вводьте себе в оману, видаляючи `assert`-и!

### Додатково

- [`std.algorithm`](http://dlang.org/phobos/std_algorithm.html)
- [`std.range`](http://dlang.org/phobos/std_range.html)

## {SourceCode:incomplete}

```d
import std.stdio;

struct FibonacciRange
{
    bool empty() const @property
    {
        // Так коли послiдовнiсть Фібоначчі
        // закiнчується?
    }

    void popFront()
    {
    }

    int front() const @property
    {
    }
}

void main()
{
    import std.range: take;
    import std.array: array;

    FibonacciRange fib;

    // `take` створює iнший дiапазон,
    // який повертає максимум N елементів.
    // Цей дiапазон є ледачим
    // та звертається до оригiнального
    // дiапазону, лише коли дiйсно потрiбно
    auto fib10 = take(fib, 10);

    // Але тут ми бажаємо отримати всі елементи
    // та перетворити дiапазон у масив цiлих
    // чисел.
    int[] the10Fibs = array(fib10);

    writeln("Перші 10 чисел Фібоначчі: ",
        the10Fibs);
    assert(the10Fibs ==
        [1, 1, 2, 3, 5, 8, 13, 21, 34, 55]);
}
```
